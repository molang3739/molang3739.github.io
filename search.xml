<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>two common use of closure</title>
      <link href="/2024/11/17/commonUseOfClosure/"/>
      <url>/2024/11/17/commonUseOfClosure/</url>
      
        <content type="html"><![CDATA[<!-- ### two common use of closure --><p>there are two common use of closure: pass function as parameter,pass function as return value</p><h2 id="pass-function-as-parameter"><a href="#pass-function-as-parameter" class="headerlink" title="pass function as parameter"></a>pass function as parameter</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function a1()&#123;</span><br><span class="line">    let a = 100;</span><br><span class="line">    return function()&#123;</span><br><span class="line">        console.log(a)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let a = 200;</span><br><span class="line">let b = a1()</span><br><span class="line">b();</span><br><span class="line">// output 100;</span><br></pre></td></tr></table></figure><p>Explanation:<br>In this example, the function a1 defines a local variable a (with a value of 100) and returns an inner function. The inner function forms a closure over a. When b is executed, it remembers the environment where it was defined, so it uses the a from a1, not the outer a &#x3D; 200.</p><h2 id="pass-function-as-return-value"><a href="#pass-function-as-return-value" class="headerlink" title="pass function as return value"></a>pass function as return value</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function fn(cb)&#123;</span><br><span class="line">    let a = 200;</span><br><span class="line">    cb()</span><br><span class="line">&#125;</span><br><span class="line">let a = 100;</span><br><span class="line">function fn2()&#123;</span><br><span class="line">    console.log(a)</span><br><span class="line">&#125;</span><br><span class="line">fn(fn2);</span><br><span class="line">//output 100</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>Explanation:<br>Here, the function fn takes a callback function cb as a parameter. When cb is executed inside fn, it still retains its original scope from the outer environment where it was defined. In this case, fn2 is defined in the global scope, so it uses the global variable a &#x3D; 100, not the a declared inside fn.</p><p>Why Both Results Are 100?<br>The key concept of closures is lexical scoping, meaning a function’s variables are resolved based on where the function is defined, not where it is called.</p><p>In the first example, the returned function remembers the variable a from its defining scope in a1 (value is 100).<br>In the second example, the function fn2 was defined in the global scope, so it uses the global variable a &#x3D; 100, even though it’s executed inside fn.<br>Closures ensure that functions “remember” the variables from their defining scope, regardless of where they are called.</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>protoType and protoType Chain</title>
      <link href="/2024/11/16/protoType%20and%20%20protoType%20Chain/"/>
      <url>/2024/11/16/protoType%20and%20%20protoType%20Chain/</url>
      
        <content type="html"><![CDATA[<p>there is simple question how can you check if a variable is an Array。<br>the answer is easy </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr instanceof Array</span><br></pre></td></tr></table></figure><p>if result is true  ,arr is Array .otherwise  arr isn’t;</p><p>so there is another question：  what’s  principle behind instanceof in Javascript</p><p>let me explain</p><p>there’re two classes. People and Student . Student implements People</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class People&#123;</span><br><span class="line">    constructor(name)&#123;</span><br><span class="line">        this.name = name</span><br><span class="line">    &#125;</span><br><span class="line">    eat()&#123;</span><br><span class="line">        console.log(`$&#123;this.name&#125; eat something`)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Student extends People&#123;</span><br><span class="line">    constructor(name,number)&#123;</span><br><span class="line">        super(name); // the parent class handles this property</span><br><span class="line">        this.number =number;</span><br><span class="line">    &#125;</span><br><span class="line">    sayHi()&#123;</span><br><span class="line">        console.log(`name $&#123;this.name&#125;, no $&#123;this.number&#125;`)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const huck = new Student(&#x27;huck&#x27;,100);</span><br><span class="line">console.log(huck.name)</span><br><span class="line">console.log(huck.number)</span><br><span class="line">huck.sayHi();</span><br></pre></td></tr></table></figure><p>“huck” is an instance of Student;</p><p>Here are the 3 basic rules in Prototype<br>“Every class in Javascript has a explicit prototype property”<br>“Every instance in Javascript has implicit prototype, <strong>proto</strong>“<br>“An instance’s <strong>proto</strong> prototype points to corresponding class”</p><p>take the value “huck” for example </p><p>huck has a <code>__proto__</code>  points to Student’s prototype.</p><p><img src="/./images/prototype/p1@2x.png" alt="protytype"></p><p>and Student‘s  <code>__proto__</code>  points to People’s prototype.</p><p><img src="/./images/prototype/p2@2x.png" alt="protytype"></p><p>and People‘s  <code>__proto__</code>  points to Object’s prototype.</p><p>Object‘s  <code>__proto__</code>  points to null</p><p><img src="/./images/prototype/p3@2x.png" alt="protytype"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>When to Use === and ==</title>
      <link href="/2024/11/13/When%20to%20Use%20===%20and%20==/"/>
      <url>/2024/11/13/When%20to%20Use%20===%20and%20==/</url>
      
        <content type="html"><![CDATA[<!-- ### When to Use === and == --><h4 id="Use-the-operator-only-when-checking-for-null-or-undefined-In-all-other-cases-use-for-strict-equality"><a href="#Use-the-operator-only-when-checking-for-null-or-undefined-In-all-other-cases-use-for-strict-equality" class="headerlink" title="Use the &#x3D;&#x3D; operator only when checking for null or undefined. In all other cases, use &#x3D;&#x3D;&#x3D; for strict equality."></a>Use the &#x3D;&#x3D; operator only when checking for null or undefined. In all other cases, use &#x3D;&#x3D;&#x3D; for strict equality.</h4><p>For example:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if(obj.a == null)&#123;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>is equivalent to:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (obj.a === null || obj.a === undefined) &#123;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Implement deepClone manually</title>
      <link href="/2024/11/13/deepClone/"/>
      <url>/2024/11/13/deepClone/</url>
      
        <content type="html"><![CDATA[<!-- #### Implement deepClone manually --><h5 id="Reason"><a href="#Reason" class="headerlink" title="Reason:"></a>Reason:</h5><p>Reference types will share the same address, so when we use &#x3D; operator, if there is modification on the new object, the value on the old object will change too.</p><h4 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h4><p>Iterate the Object recursively. If there is reference type, we create a new one and copy all the value type to the new reference type.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">function deepClone(obj = &#123;&#125;) &#123;</span><br><span class="line">    // null can&#x27;t be treated as object</span><br><span class="line">    if (typeof obj != &quot;object&quot; || obj === null) &#123;</span><br><span class="line">        console.log(obj, &quot;obj&quot;);</span><br><span class="line">        return obj;</span><br><span class="line">    &#125;</span><br><span class="line">    let result;</span><br><span class="line">    // create a new reference type</span><br><span class="line">    if (obj instanceof Array) &#123;</span><br><span class="line">        result = [];</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        result = &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    for (let key in obj) &#123;</span><br><span class="line">        // make sure key is not on prototype</span><br><span class="line">        if (obj.hasOwnProperty(key)) &#123;</span><br><span class="line">            result[key] = deepClone(obj[key]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line">let obj1 = &#123; x: 100, y: 200, z: [1, 2, 3], c: null &#125;;</span><br><span class="line">let obj2 = deepClone(obj1);</span><br><span class="line">console.log(obj2);</span><br><span class="line">obj2.x = 102;</span><br><span class="line">console.log(obj2, obj1);</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>decode message</title>
      <link href="/2024/03/26/decode%20message/"/>
      <url>/2024/03/26/decode%20message/</url>
      
        <content type="html"><![CDATA[<p>There is a interview question on bfe.dev about decode-message. The link is below </p><p><a href="https://bigfrontend.dev/problem/decode-message">https://bigfrontend.dev/problem/decode-message</a></p><p>Your are given a 2-D array of characters. There is a hidden message in it.</p>   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">I B C A L K A</span><br><span class="line">D R F C A E A</span><br><span class="line">G H O E L A D</span><br></pre></td></tr></table></figure><p>col and row are marked with number which start from 0. The number of col is  0 ~ 6 ,and the number of row is 0~2<br>The way to collect the message is as follows</p><ol><li>start at top left</li><li>move diagonally down right</li><li>when cannot move any more, try to switch to diagonally up right</li><li>when cannot move any more, try switch to diagonally down right, repeat 3</li><li>stop when cannot neither move down right or up right. the character on the path is the message<br>for the input above, IROCLED should be returned<br>notes:<br>if no characters could be collected, return empty string</li></ol><p>now we have a matrix of 3 rows , 7 columns.<br>we’ll start at  coordinates   [0,0] . and next we’ll move to [1,1] ,the rest coordinates will be [2,2]<br>[3,1]  [4,0] [5,1] [6,2] </p><p>so in the function  decode,it recieves  a 2D array</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param &#123;string[][]&#125; message</span><br><span class="line"> * @return &#123;string&#125;</span><br><span class="line"> */</span><br><span class="line">function decode(message) &#123;</span><br><span class="line">  // your code here</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">message=[</span><br><span class="line">[I, B, C, A, L, K, A],</span><br><span class="line">[D, R, F, C, A, E, A],</span><br><span class="line">[G, H, O, E, L,A, D]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>The value of variable   rows will be the lenght of messsage ,that’s  message.length ,and it is 3 .<br>The  value of  varibable columns will be message[0].length ,and  it’s 7 .<br>if the rows or columns is 0 , the function should return.<br>and we set the default value  of variable  result as ‘’ ;<br>we set row as 0 and  col as 0;<br>we use a while loop  to get every col in columns,codes are blow</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param &#123;string[][]&#125; message</span><br><span class="line"> * @return &#123;string&#125;</span><br><span class="line"> */</span><br><span class="line">function decode(message) &#123;</span><br><span class="line">  if(message.length === 0)return &#x27;&#x27;;</span><br><span class="line">  if(message[0].length===0) return &#x27;&#x27;;</span><br><span class="line">  let rows = message.length;</span><br><span class="line">  let cols = message[0].length;</span><br><span class="line"></span><br><span class="line">  let result = &#x27;&#x27;;</span><br><span class="line">  let row = 0;</span><br><span class="line">  let col = 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>   we use a while loop to get every col in columns<br> so in the loop  col will alway plus 1    ,row will plus the direction which name is directionY ,when row is bigger than 2 ,that is row&gt; rows-1 ,directionY should be -1 ,row have to minus 2<br> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if(row&gt;rows-1)&#123;</span><br><span class="line">  directonY = -1;</span><br><span class="line">  row -=2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>if row is small than 0 ,we in the top of matrix , In this case directionY should be 1 ,row have to add 2</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if(row&lt;0)&#123;</span><br><span class="line">  directonY = 1;</span><br><span class="line">  row +=2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>row also have a  limitation ,as we  doing row-&#x3D;2 ,and row +&#x3D;2; we can’t let row out of the matrix .so row must bigger than -1 ,and &lt; rows.<br>the function is blow ,and it passed the test.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @param &#123;string[][]&#125; message</span><br><span class="line"> * @return &#123;string&#125;</span><br><span class="line"> */</span><br><span class="line">function decode(message) &#123;</span><br><span class="line">  if(message.length === 0)return &#x27;&#x27;;</span><br><span class="line">  if(message[0].length===0) return &#x27;&#x27;;</span><br><span class="line">  let rows = message.length;</span><br><span class="line">  let cols = message[0].length;</span><br><span class="line"></span><br><span class="line">  let result = &#x27;&#x27;;</span><br><span class="line">  let row = 0;</span><br><span class="line">  let col = 0;</span><br><span class="line">  let directionY = 1;</span><br><span class="line">  /**</span><br><span class="line">  when col = 3 ,row =  3  </span><br><span class="line">  rows =3  , 3 &gt; 3-1</span><br><span class="line">  */</span><br><span class="line">  while(col &lt; cols &amp;&amp; row &gt;-1 &amp;&amp; row&lt;rows)&#123;</span><br><span class="line">    result += message[row][col]</span><br><span class="line">    col+=1</span><br><span class="line">    row +=directionY</span><br><span class="line">  </span><br><span class="line">  if(row&gt;rows-1)&#123;</span><br><span class="line">    directionY = -1;</span><br><span class="line">    row -= 2</span><br><span class="line">  &#125;else if(row&lt;0)&#123;</span><br><span class="line">     directionY = 1;</span><br><span class="line">    row += 2</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return result</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Implementing the apply Function Manually</title>
      <link href="/2024/02/26/ImplementingTheApplyFunctionManually/"/>
      <url>/2024/02/26/ImplementingTheApplyFunctionManually/</url>
      
        <content type="html"><![CDATA[<!-- ##  Implementing the apply Function Manually --><h3 id="Steps-to-implement-the-apply-function"><a href="#Steps-to-implement-the-apply-function" class="headerlink" title="Steps to implement the apply function:"></a>Steps to implement the apply function:</h3><ol><li><p>Determine if the calling object is a function. Even though it’s defined on the function’s prototype, there may be instances where it is invoked using methods like call.</p></li><li><p>Check if the incoming context object exists; if not, set it to window.</p></li><li><p>Assign the function as a property of the context object.</p></li><li><p>Determine if the parameter values have been passed in.</p></li><li><p>Invoke the method using the context object and save the returned result.</p></li><li><p>Remove the property that was just added.</p></li><li><p>Return the result</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// apply </span><br><span class="line">Function.prototype.myApply = function(context) &#123;</span><br><span class="line">  </span><br><span class="line">  if (typeof this !== &quot;function&quot;) &#123;</span><br><span class="line">    throw new TypeError(&quot;Error&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  let result = null;</span><br><span class="line">  // check context  or set to window</span><br><span class="line">  context = context || window;</span><br><span class="line">  // set funcion</span><br><span class="line">  context.fn = this;</span><br><span class="line">  // call the method</span><br><span class="line">  if (arguments[1]) &#123;</span><br><span class="line">    result = context.fn(...arguments[1]);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    result = context.fn();</span><br><span class="line">  &#125;</span><br><span class="line">  // del property</span><br><span class="line">  delete context.fn;</span><br><span class="line">  return result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><h3 id="Implementing-the-bind-Function-Manually"><a href="#Implementing-the-bind-Function-Manually" class="headerlink" title="Implementing the bind Function Manually"></a>Implementing the bind Function Manually</h3><h4 id="Steps-to-implement-the-bind-function"><a href="#Steps-to-implement-the-bind-function" class="headerlink" title="Steps to implement the bind function:"></a>Steps to implement the bind function:</h4><ol><li><p>Determine if the calling object is a function. Even though it’s defined on the function’s prototype, there may be instances where it is invoked using methods like call.</p></li><li><p>Save a reference to the current function and retrieve the rest of the passed-in parameter values.</p></li><li><p>Return a new function.</p></li><li><p>Internally, the function uses apply to bind the function call. It’s important to account for the function being used as a constructor. In such cases, the current function’s ‘this’ needs to be passed to apply, while in all other cases, the specified context object is passed.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// bind </span><br><span class="line">Function.prototype.myBind = function(context) &#123;</span><br><span class="line">  </span><br><span class="line">  if (typeof this !== &quot;function&quot;) &#123;</span><br><span class="line">    throw new TypeError(&quot;Error&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  // get parm</span><br><span class="line">  var args = [...arguments].slice(1),</span><br><span class="line">      fn = this;</span><br><span class="line">  return function Fn() &#123;</span><br><span class="line">    return fn.apply(</span><br><span class="line">      this instanceof Fn ? this : context,</span><br><span class="line">      args.concat(...arguments)</span><br><span class="line">    );</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Flatten the array</title>
      <link href="/2024/02/05/FlattenArray/"/>
      <url>/2024/02/05/FlattenArray/</url>
      
        <content type="html"><![CDATA[ <!-- ### Flatten the array --><h4 id="1-Recursive-implementation"><a href="#1-Recursive-implementation" class="headerlink" title="(1) Recursive implementation"></a>(1) Recursive implementation</h4><p>The common idea behind recursion is straightforward, involving a circular recursion approach where each item is iterated over. If an item is still an array, the process continues recursively to achieve the concatenation of each array item.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">let arr = [1, [2, [3, 4, 5]]];</span><br><span class="line">function flatten(arr) &#123;</span><br><span class="line">  let result = [];</span><br><span class="line"></span><br><span class="line">  for(let i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">    if(Array.isArray(arr[i])) &#123;</span><br><span class="line">      result = result.concat(flatten(arr[i]));</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      result.push(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br><span class="line">flatten(arr);  //  [1, 2, 3, 4，5]</span><br></pre></td></tr></table></figure><h4 id="2-reduce-function-iteration"><a href="#2-reduce-function-iteration" class="headerlink" title="(2) reduce function iteration"></a>(2) reduce function iteration</h4><p>From the ordinary recursive function described above, it’s clear that each array item is processed individually. In fact, the reduce method can also be used for array concatenation, thus simplifying the code from the first method. The transformed code is as follows:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let arr = [1, [2, [3, 4]]];</span><br><span class="line">function flatten(arr) &#123;</span><br><span class="line">    return arr.reduce(function(prev, next)&#123;</span><br><span class="line">        return prev.concat(Array.isArray(next) ? flatten(next) : next)</span><br><span class="line">    &#125;, [])</span><br><span class="line">&#125;</span><br><span class="line">console.log(flatten(arr));//  [1, 2, 3, 4，5]</span><br></pre></td></tr></table></figure><h4 id="3-Extension-operator-implementation"><a href="#3-Extension-operator-implementation" class="headerlink" title="(3) Extension operator implementation"></a>(3) Extension operator implementation</h4><p>This method’s implementation involves the use of the spread operator and the some method, both used in conjunction to achieve array flattening:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let arr = [1, [2, [3, 4]]];</span><br><span class="line">function flatten(arr) &#123;</span><br><span class="line">    while (arr.some(item =&gt; Array.isArray(item))) &#123;</span><br><span class="line">        arr = [].concat(...arr);</span><br><span class="line">    &#125;</span><br><span class="line">    return arr;</span><br><span class="line">&#125;</span><br><span class="line">console.log(flatten(arr)); //  [1, 2, 3, 4，5]</span><br></pre></td></tr></table></figure><h4 id="（4）split-and-toString"><a href="#（4）split-and-toString" class="headerlink" title="（4）split and toString"></a>（4）split and toString</h4><p>The split and toString methods are used to flatten the array. Since the array has a toString method by default, you can convert the array directly to a comma-separated string, and then use the split method to convert the string back to the array, as shown in the following code:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let arr = [1, [2, [3, 4]]];</span><br><span class="line">function flatten(arr) &#123;</span><br><span class="line">    return arr.toString().split(&#x27;,&#x27;);</span><br><span class="line">&#125;</span><br><span class="line">console.log(flatten(arr)); //  [1, 2, 3, 4，5]</span><br></pre></td></tr></table></figure><p>Using these two methods, a multidimensional array can be directly converted into a comma-separated string, which is then split back into an array.</p><p>####(5) flat in ES6</p><p>We can also directly call the flat method in ES6 to implement array flattening. Syntax for the flat method: arr.flat([depth])</p><p>depth is the parameter of flat, depth is the expansion depth of the array can be passed (the default is not filled, the value is 1), that is, expand a layer of array. If the number of layers is uncertain, the parameter can be passed into Infinity, which means that no matter how many layers are expanded:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let arr = [1, [2, [3, 4]]];</span><br><span class="line">function flatten(arr) &#123;</span><br><span class="line">  return arr.flat(Infinity);</span><br><span class="line">&#125;</span><br><span class="line">console.log(flatten(arr)); //  [1, 2, 3, 4，5]</span><br></pre></td></tr></table></figure><p>As you can see, a nested array of two layers achieves the desired effect by setting the parameter of the flat method to Infinity. In fact, it can also be set to 2, which can also achieve this effect. In the programming process, if the number of nested layers of the array is uncertain, it is best to use Infinity directly, which can achieve flatness.</p><h4 id="6-RE-and-JSON-methods"><a href="#6-RE-and-JSON-methods" class="headerlink" title="(6) RE and JSON methods"></a>(6) RE and JSON methods</h4><p>The toString method is already used in the fourth method, which still uses the JSON.stringify method to convert it to a string, then filters out the array square brackets in the string through regular expressions, and finally converts it to an array using JSON.parse:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let arr = [1, [2, [3, [4, 5]]], 6];</span><br><span class="line">function flatten(arr) &#123;</span><br><span class="line">  let str = JSON.stringify(arr);</span><br><span class="line">  str = str.replace(/(\[|\])/g, &#x27;&#x27;);</span><br><span class="line">  str = &#x27;[&#x27; + str + &#x27;]&#x27;;</span><br><span class="line">  return JSON.parse(str); </span><br><span class="line">&#125;</span><br><span class="line">console.log(flatten(arr)); //  [1, 2, 3, 4，5]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Implement deep copy</title>
      <link href="/2024/02/05/deepCopy/"/>
      <url>/2024/02/05/deepCopy/</url>
      
        <content type="html"><![CDATA[<!-- ### Implement deep copy --><p>  ○ Shallow copy: Shallow copy refers to copying the attribute value of one object to another object. If the attribute value is a reference type, then the address of the reference is copied to the object, so the two objects will have a reference of the same reference type. Shallow copying can be implemented using Object.assign() and the spread operator.</p><p>  ○ Deep copy: Compared to shallow copy, if a property value is a reference type, deep copy creates a reference type and copies the corresponding value to it, so the object gets a new reference type instead of a reference of the original type. Deep copying can be  achieved for some objects using two JSON functions. However, due to JSON’s stricter object format compared to JavaScript’s, this method fails if the object contains functions or Symbol types.</p><h4 id="（1）JSON-stringify"><a href="#（1）JSON-stringify" class="headerlink" title="（1）JSON.stringify()"></a>（1）JSON.stringify()</h4><p>  ○ JSON.parse(JSON.stringify(obj)) is one of the most commonly used deep copy methods. Its principle is to use JSON.stringify to serialize the JavaScript object into a JSON string, and then use JSON.parse() to deserialize (restore) the JavaScript object.</p><p>  ○ This method can be a simple implementation of deep copy, but there is a problem -  functions, undefined, and Symbol values in the copied object will be lost after processing with JSON.stringify().</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let obj1 = &#123;  a: 0,</span><br><span class="line">              b: &#123;</span><br><span class="line">                 c: 0</span><br><span class="line">                 &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">let obj2 = JSON.parse(JSON.stringify(obj1));</span><br><span class="line">obj1.a = 1;</span><br><span class="line">obj1.b.c = 1;</span><br><span class="line">console.log(obj1); // &#123;a: 1, b: &#123;c: 1&#125;&#125;</span><br><span class="line">console.log(obj2); // &#123;a: 0, b: &#123;c: 0&#125;&#125;</span><br></pre></td></tr></table></figure><h4 id="2-Library-lodash’s-cloneDeep-method"><a href="#2-Library-lodash’s-cloneDeep-method" class="headerlink" title="(2) Library lodash’s.cloneDeep method"></a>(2) Library lodash’s.cloneDeep method</h4><p>The library also provides _.cloneDeep() for Deep Copying.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var _ = require(&#x27;lodash&#x27;);</span><br><span class="line">var obj1 = &#123;</span><br><span class="line">    a: 1,</span><br><span class="line">    b: &#123; f: &#123; g: 1 &#125; &#125;,</span><br><span class="line">    c: [1, 2, 3]</span><br><span class="line">&#125;;</span><br><span class="line">var obj2 = _.cloneDeep(obj1);</span><br><span class="line">console.log(obj1.b.f === obj2.b.f);// false</span><br></pre></td></tr></table></figure><h4 id="3-Handwritten-Deep-Copy-Function-Implementation"><a href="#3-Handwritten-Deep-Copy-Function-Implementation" class="headerlink" title="(3) Handwritten Deep Copy Function Implementation"></a>(3) Handwritten Deep Copy Function Implementation</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function deepCopy(object) &#123;</span><br><span class="line">  if (!object || typeof object !== &quot;object&quot;) return;</span><br><span class="line"></span><br><span class="line">  let newObject = Array.isArray(object) ? [] : &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  for (let key in object) &#123;</span><br><span class="line">    if (object.hasOwnProperty(key)) &#123;</span><br><span class="line">      newObject[key] =</span><br><span class="line">        typeof object[key] === &quot;object&quot; ? deepCopy(object[key]) : object[key];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return newObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>What is the purpose of the newly added primitive data type &quot;Symbol&quot;?</title>
      <link href="/2024/01/28/Symbol/"/>
      <url>/2024/01/28/Symbol/</url>
      
        <content type="html"><![CDATA[<!-- ### What is the purpose of the newly added primitive data type "Symbol"? --><h4 id="Discuss-conceptual-questions"><a href="#Discuss-conceptual-questions" class="headerlink" title="Discuss conceptual questions"></a>Discuss conceptual questions</h4><p>‘Symbol’ is a primitive data type introduced in ES6. Its primary purpose is to create a unique identifier, which is used in scenarios such as naming object properties, defining constants, and so on.</p><p>Understanding with Examples</p><p>Each ‘Symbol’ is unique and can be used as a property name for objects, which helps to avoid conflicts with property names. For example:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const s1 = Symbol();</span><br><span class="line">const s2 = Symbol();</span><br><span class="line">const obj = &#123;</span><br><span class="line"> [s1]: &#x27;hello&#x27;,</span><br><span class="line"> [s2]: &#x27;world&#x27;</span><br><span class="line">&#125;;</span><br><span class="line">console.log(obj[s1]); // &quot;hello&quot;console.log(obj[s2]); // &quot;world&quot;</span><br></pre></td></tr></table></figure><p>In addition, symbol can also be used to implement constants or enumeration values, which are immutable and unique, such as:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const Colors = &#123;</span><br><span class="line"> Red: Symbol(&#x27;Red&#x27;),</span><br><span class="line"> Green: Symbol(&#x27;Green&#x27;),</span><br><span class="line"> Blue: Symbol(&#x27;Blue&#x27;)</span><br><span class="line">&#125;;</span><br><span class="line">console.log(Colors.Red); // Symbol(Red)console.log(Colors.Green); // Symbol(Green)console.log(Colors.Blue); // Symbol(Blue)</span><br></pre></td></tr></table></figure><p>As Symbol is a primitive data type, it offers high performance and reliability, making it suitable for scenarios requiring efficient and secure creation and usage of identifiers.</p><h3 id="Important-Considerations"><a href="#Important-Considerations" class="headerlink" title="Important Considerations"></a>Important Considerations</h3><p>Another significant characteristic of Symbol is that it does not appear in object property iteration methods like for…in, for…of, Object.keys(), Object.getOwnPropertyNames(), and so on. Therefore, it can be used to define properties that should not be iterated over, such as internal implementation details or hidden attributes.</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>What are the differences in asynchronous loading of JS scripts?</title>
      <link href="/2024/01/28/asynchronousLoading/"/>
      <url>/2024/01/28/asynchronousLoading/</url>
      
        <content type="html"><![CDATA[<h3 id="What-are-the-differences-in-asynchronous-loading-of-JS-scripts"><a href="#What-are-the-differences-in-asynchronous-loading-of-JS-scripts" class="headerlink" title="What are the differences in asynchronous loading of JS scripts?"></a>What are the differences in asynchronous loading of JS scripts?</h3><h2 id="In-Web-applications-the-asynchronous-loading-of-JavaScript-scripts-can-be-achieved-in-the-following-ways"><a href="#In-Web-applications-the-asynchronous-loading-of-JavaScript-scripts-can-be-achieved-in-the-following-ways" class="headerlink" title="In Web applications, the asynchronous loading of JavaScript scripts can be achieved in the following ways:"></a>In Web applications, the asynchronous loading of JavaScript scripts can be achieved in the following ways:</h2><p>  a. Dynamically create a <script> tag and set its src attribute to the URL of the script to be loaded. You can use the onload or onreadystatechange event to check if the script has finished loading.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const script = document.createElement(&#x27;script&#x27;);</span><br><span class="line">script.src = &#x27;path/to/script.js&#x27;;</span><br><span class="line">script.onload = function() &#123;</span><br><span class="line"> // </span><br><span class="line">&#125;;</span><br><span class="line">document.body.appendChild(script);</span><br></pre></td></tr></table></figure><p>  b. Use the XMLHttpRequest object or the Fetch API to send an asynchronous request. After a successful request, parse the response text into JavaScript code, and then use the eval() function or Function() constructor to execute the script.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const xhr = new XMLHttpRequest();</span><br><span class="line">xhr.open(&#x27;GET&#x27;, &#x27;path/to/script.js&#x27;);</span><br><span class="line">xhr.onload = function() &#123;</span><br><span class="line"> const script = document.createElement(&#x27;script&#x27;);</span><br><span class="line"> script.textContent = xhr.responseText;</span><br><span class="line"> document.head.appendChild(script);</span><br><span class="line">&#125;;</span><br><span class="line">xhr.send();</span><br></pre></td></tr></table></figure><h3 id="These-two-methods-can-be-used-to-implement-the-asynchronous-loading-of-JavaScript-scripts-Compared-to-synchronous-loading-asynchronous-loading-has-the-following-differences"><a href="#These-two-methods-can-be-used-to-implement-the-asynchronous-loading-of-JavaScript-scripts-Compared-to-synchronous-loading-asynchronous-loading-has-the-following-differences" class="headerlink" title="These two methods can be used to implement the asynchronous loading of JavaScript scripts. Compared to synchronous loading, asynchronous loading has the following differences:"></a>These two methods can be used to implement the asynchronous loading of JavaScript scripts. Compared to synchronous loading, asynchronous loading has the following differences:</h3><p>  a. Asynchronous loading can improve the loading speed and response performance of the page, and avoid the situation that the page is stuck due to JavaScript blocking.</p><p>  b. Asynchronous loading avoids the blocking caused by loading scripts and allows other resources of the page to load and render faster.</p><p>  c. Asynchronous loading allows you to flexibly control the loading sequence and the execution time of scripts, and dynamically load and unload scripts based on page requirements, thus improving page maintainability and expansibility.</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Why is the result of &#39;typeof null&#39; an &#39;object&#39;?</title>
      <link href="/2024/01/21/typeof%20null/"/>
      <url>/2024/01/21/typeof%20null/</url>
      
        <content type="html"><![CDATA[<h3 id="Why-is-the-result-of-‘typeof-null’-an-‘object’"><a href="#Why-is-the-result-of-‘typeof-null’-an-‘object’" class="headerlink" title="Why is the result of ‘typeof null’ an ‘object’?"></a>Why is the result of ‘typeof null’ an ‘object’?</h3><h2 id="Kernel"><a href="#Kernel" class="headerlink" title="Kernel"></a>Kernel</h2><p>The result of ‘typeof null’ being “object” is a legacy issue of the JavaScript language.</p><p>In the original version of JavaScript, a 32-bit value was used to represent a variable, with the first 3 bits representing the type of the value. 000 represents an object, 010 represents a floating point number, 100 represents a string, 110 represents a Boolean value, and other values are all considered pointers.</p><p>In this representation, null was interpreted as an all-zero pointer, that is, it is considered to be an empty object reference, so the result of typeof null is “object”.</p><h2 id="expand"><a href="#expand" class="headerlink" title="expand"></a>expand</h2><p>Although this design is a legacy issue, it has become part of the JavaScript language for historical reasons and cannot be fixed. Therefore, it is recommended to use the strict equality operator (&#x3D;&#x3D;&#x3D;) when determining whether a variable is null.</p><p>Can variables globally declared with ‘let’ be accessed via the window object?</p><p>Variables declared with ‘let’ are not attached to the global ‘window’ object, and therefore cannot be accessed via ‘window.variablename’. This is different from variables declared with ‘var’, which are mounted on the global object and can be accessed via ‘window.variableName’.</p><p>For example, consider the following code:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let foo = &#x27;bar&#x27;;</span><br><span class="line">var baz = &#x27;qux&#x27;;</span><br><span class="line">console.log(window.foo); // undefined</span><br><span class="line">console.log(window.baz); // &#x27;qux&#x27;</span><br></pre></td></tr></table></figure><p>In this code, the variable ‘foo’ declared with ‘let’ is not accessible through ‘window.foo’, while the variable ‘baz’ declared with ‘var’ is accessible through ‘window.baz’.</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>What are the uses of &#39;requestAnimationFrame&#39; and &#39;requestIdleCallback&#39;, respectively?</title>
      <link href="/2024/01/21/RequestAnimationFrame%20requestIdleCallback/"/>
      <url>/2024/01/21/RequestAnimationFrame%20requestIdleCallback/</url>
      
        <content type="html"><![CDATA[<!-- ### What are the uses of 'requestAnimationFrame' and 'requestIdleCallback', respectively? --><p>‘RequestAnimationFrame’ and ‘requestIdleCallback’ are both APIs used for performing animations or other high-performance tasks in the browser.</p><p>‘RequestAnimationFrame’ is a mechanism provided by browsers to request an animation frame. It executes a specified callback function right before the browser’s next redraw. The advantage of this approach is that it allows the browser to automatically perform complex calculations and rendering tasks during the next draw, thus preventing the browser from repeating the same tasks within a short period. Using requestAnimationFrame can lead to smoother animations and reduce flickering and stuttering on web pages.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function animate() &#123;</span><br><span class="line"> // requestAnimationFrame(animate);</span><br><span class="line">&#125;</span><br><span class="line">requestAnimationFrame(animate);</span><br></pre></td></tr></table></figure><p>RequestIdleCallback is a relatively new API that performs a specified callback function when the browser is idle. The purpose of this API is to enable developers to perform time-consuming tasks such as computation and rendering when the browser is idle. The advantage of this is that it can improve the performance and responsiveness of the web page, while also avoiding blocking the main thread of the browser, resulting in a poor user experience.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function doWork(deadline) &#123;</span><br><span class="line"> while (deadline.timeRemaining() &gt; 0) &#123;</span><br><span class="line"> // code here</span><br><span class="line"> &#125;</span><br><span class="line"> if (other task) &#123;</span><br><span class="line"> requestIdleCallback(doWork);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">requestIdleCallback(doWork);</span><br></pre></td></tr></table></figure><p>Note that the callback function of requestIdleCallback accepts an IdleDeadline parameter, which contains information about the current idle time. Developers can use this parameter to schedule and optimize tasks according to the idle time of the browser.</p><p>In summary, requestAnimationFrame is suitable for animation tasks that need to be executed before the next drawing, while requestIdleCallback is suitable for time-consuming tasks that need to be executed when the browser is idle.</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Differences among Ajax, axios, and fetch</title>
      <link href="/2024/01/14/Ajax%20axios%20fetch/"/>
      <url>/2024/01/14/Ajax%20axios%20fetch/</url>
      
        <content type="html"><![CDATA[<!-- # Differences among Ajax, axios, and fetch --><h2 id="（1）AJAX"><a href="#（1）AJAX" class="headerlink" title="（1）AJAX"></a>（1）AJAX</h2><p>Ajax stands for “Asynchronous JavaScript and XML.” It’s a way to make web pages interactive without reloading the whole page. Ajax updates parts of a page by fetching a bit of data from the server behind the scenes. This means updates can happen without a full page refresh. Traditional web pages without Ajax need a full reload to update. However, Ajax is not perfect:</p><p>● It’s more suited for MVC programming, not quite in line with the front-end MVVM trend.</p><p>● Built on the not-so-clear architecture of native XHR.</p><p>● Doesn’t quite stick to the Separation of Concerns principle.</p><p>● Setup and calling methods can be a bit messy, and its event-based async model isn’t friendly.</p><h2 id="（2）Fetch"><a href="#（2）Fetch" class="headerlink" title="（2）Fetch"></a>（2）Fetch</h2><p>Fetch is often seen as AJAX’s replacement, coming into play with ES6 and using its promise objects. It’s all about promises, making its code structure way simpler than Ajax. Fetch isn’t just a rewrap of Ajax; it’s native JavaScript and does not use XMLHttpRequest objects.</p><h3 id="The-cool-things-about-fetch"><a href="#The-cool-things-about-fetch" class="headerlink" title="The cool things about fetch:"></a>The cool things about fetch:</h3><p>● Straightforward syntax, more semantic.</p><p>● Built on the standard Promise, supports async&#x2F;await.</p><p>● More fundamental, comes with a rich set of APIs (request, response).</p><p>● Moves away from XHR, offering a new approach in ES standards.</p><h3 id="The-not-so-cool-things-about-fetch"><a href="#The-not-so-cool-things-about-fetch" class="headerlink" title="The not-so-cool things about fetch:"></a>The not-so-cool things about fetch:</h3><p>● It only throws errors for network issues, treating 400s and 500s as successes. It won’t reject for these server errors unless it’s a network problem.</p><p>● By default, fetch won’t carry cookies. You need to tweak it with: fetch(url, {credentials: ‘include’}).</p><p>● Lacks support for aborting requests or controlling timeouts. Workarounds like setTimeout and Promise.reject can’t stop the ongoing background process, wasting data.</p><p>● Can’t natively track the progress of requests, unlike XHR.</p><h2 id="（3）Axios"><a href="#（3）Axios" class="headerlink" title="（3）Axios"></a>（3）Axios</h2><p>Axios is a Promise-based HTTP client. It’s features are as follows:</p><p>● Launches XMLHttpRequests from browsers.</p><p>● Handles HTTP requests in Node.js.</p><p>● Supports the Promise API.</p><p>● Tracks requests and responses.</p><p>● Transforms requests and responses.</p><p>● Can cancel requests.</p><p>● Automatically handles JSON data.</p><p>● The client side supports to guard against XSRF attacks.</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Understanding the execution context</title>
      <link href="/2024/01/14/execution%20context/"/>
      <url>/2024/01/14/execution%20context/</url>
      
        <content type="html"><![CDATA[<!-- ## Understanding the execution context  --><ol><li>Execution context type</li></ol><p>（1）global execution context</p><p>Anything that is not inside a function is a global execution context. It first creates a global window object and sets the value of this object to be equal to this global object. A program has only one global execution context. </p><p>（2）function execution context</p><p>When a function is called, a new execution context is created for the function. The context of the function can be as many as possible. </p><p>（3）* * eval * * function execution context  </p><p>the code executed in the eval function has its own execution context. However, the eval function is not often used and is not introduced. </p><h2 id="2-Execute-the-context-stack"><a href="#2-Execute-the-context-stack" class="headerlink" title="2. Execute the context stack"></a>2. Execute the context stack</h2><p>● the JavaScript engine uses the execution context stack to manage the execution context.</p><p>● when the JavaScript executes the code, it first encounters the global code, creates a global execution context and presses it into the execution stack. Whenever a function call is encountered, it creates a new execution context for the function and presses it into the top of the stack. The engine executes the function at the top of the execution context stack. After the function execution is completed, the execution context pops up from the stack and continues to execute the next context. After all the code is executed, the global execution context pops up from the stack.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">let a = &#x27;Hello World!&#x27;;</span><br><span class="line">function first() &#123;</span><br><span class="line">  console.log(&#x27;Inside first function&#x27;);</span><br><span class="line">  second();</span><br><span class="line">  console.log(&#x27;Again inside first function&#x27;);</span><br><span class="line">&#125;</span><br><span class="line">function second() &#123;</span><br><span class="line">  console.log(&#x27;Inside second function&#x27;);</span><br><span class="line">&#125;</span><br><span class="line">first();</span><br><span class="line">//order of excution</span><br><span class="line">// second()  first()</span><br></pre></td></tr></table></figure><h2 id="3-Create-an-execution-context"><a href="#3-Create-an-execution-context" class="headerlink" title="3. Create an execution context"></a>3. Create an execution context</h2><p>there are two phases to create an execution context: creation phase and execution phase </p><h3 id="1）creation-phase"><a href="#1）creation-phase" class="headerlink" title="1）creation phase"></a>1）creation phase</h3><p> （1）this binding<br>●<br>in the context of global execution, this point to a global object (window object) </p><p>●<br>in the context of function execution, this point depends on how the function is called. If it is called by a reference object, this is set to that object, otherwise the value of this is set to global object or undefined </p><p>###（2）create lexical environment components </p><p>●<br>lexical environment is a kind identifier – Variable mapping the identifier refers to the variable&#x2F;function name, and the variable is a reference to the actual object or raw data.</p><p>●<br>the lexical environment has two internal components: bold Style : environment recorder: used to store the actual location of variable function declarations references to external environments : you can access the parent scope. </p><p>###（3）Create a variable environment component</p><p>●<br>the variable environment is also a lexical environment. Its environment recorder holds the binding relationship created in the execution context of the variable declaration statement. </p><h3 id="2）execution-phase"><a href="#2）execution-phase" class="headerlink" title="2）execution phase"></a>2）execution phase</h3><p>At this stage, variables are allocated and the code is executed. </p><p>In short, the execution context refers:</p><p>Before executing a little JS code, you need to parse the code. When parsing, a global execution context is created. First, the variables and function declarations to be executed in the code are taken out. The variables are assigned to undefined first, and the functions are declared to be available. After this step is completed, the formal execution procedure is started. </p><p>Before a function is executed, a function execution context is also created, which is similar to the global execution context. However, this, arguments, and function parameters are added to the function execution context. </p><p>●<br>global Context: variable definition, function declaration </p><p>●<br>function context: variable definition, function declaration, this , arguments</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>The understanding of array-like objects</title>
      <link href="/2024/01/14/array-like%20objects/"/>
      <url>/2024/01/14/array-like%20objects/</url>
      
        <content type="html"><![CDATA[<h1 id="1、The-understanding-of-array-like-objects-and-How-to-convert-them-into-arrays"><a href="#1、The-understanding-of-array-like-objects-and-How-to-convert-them-into-arrays" class="headerlink" title="1、The understanding of array-like objects  ,and How to convert them into arrays?"></a>1、The understanding of array-like objects  ,and How to convert them into arrays?</h1><p>An object with the length attribute and several Index attributes can be called a array-like object. Array-like objects are similar to arrays, but array methods cannot be called. Common array-like objects include arguments and DOM methods. Function parameters can also be considered as array-like objects because they contain the length attribute value, which represents the number of parameters that can be received. </p><h2 id="There-are-several-common-methods-to-convert-array-like-arrays-into-arrays"><a href="#There-are-several-common-methods-to-convert-array-like-arrays-into-arrays" class="headerlink" title="There are several common methods to convert array-like arrays into arrays:"></a>There are several common methods to convert array-like arrays into arrays:</h2><p>●<br>call the slice method of the array to implement conversion.<br>Array.prototype.slice.call(arrayLike);</p><p>●<br>call the splice method of an array to implement conversion.<br>Array.prototype.splice.call(arrayLike, 0);</p><p>●<br>use apply to call the concat method of an array to implement conversion<br>Array.prototype.concat.apply([], arrayLike);</p><p>●<br>use the Array.from Method to implement conversion<br>Array.from(arrayLike);</p><h1 id="2-Can-the-properties-of-const-objects-be-modified"><a href="#2-Can-the-properties-of-const-objects-be-modified" class="headerlink" title="2.Can the properties of const objects be modified"></a>2.Can the properties of const objects be modified</h1><p>what const guarantees  is not  the value of a variable cannot be changed, but that the memory address to which the variable points cannot be changed.</p><p>For basic data types (numbers, strings, boolean values), their values are stored at the memory address the variable points to, so it is equivalent to a constant.</p><p>But for data of reference type (mainly objects and arrays), the variable points to the memory address of the data, saving only a pointer, const can only guarantee that the pointer is fixed, as it points to the data structure is not mutable, it can not control.</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Differences between map and weakMap</title>
      <link href="/2024/01/14/map%20weakMap/"/>
      <url>/2024/01/14/map%20weakMap/</url>
      
        <content type="html"><![CDATA[<!-- # Differences between map and weakMap --><h2 id="（1）Map"><a href="#（1）Map" class="headerlink" title="（1）Map"></a>（1）Map</h2><p>map is essentially a set of key-value pairs, but the key in a common Object can only be a string. The Map data structure provided by ES6 is similar to that of an object, but its keys do not limit the range. It can be of any type and is a more complete Hash structure. If the Map key is an original data type, it is considered the same key as long as the two keys are strictly the same. </p><p>In fact, Map is an array, and each of its data is also an array, with the following format:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const map = [</span><br><span class="line">     [&quot;name&quot;,&quot;John&quot;],</span><br><span class="line">     [&quot;age&quot;,18],</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>The Map data structure has the following operation methods:</p><p>● size： map.size<br>    map. size returns the total number of members of the Map structure. </p><p>● set(key,value)：<br>  set the key value corresponding to the key name and key, and then return the entire Map structure. If the key already has a value, the key value is updated. Otherwise, the key is generated. (Because the current Map object is returned, it can be called in chain) </p><p>● get(key)：<br>    This method reads the key value corresponding to the key. If the key cannot be found, the undefined is returned. </p><p>● has(key)：<br>    This method returns a boolean value indicating whether a key is in the current Map object.<br>● delete(key)：</p><p> This method deletes a key and returns true. If the key fails to be deleted, false is returned.</p><p>● clear()：<br>    map.clear() clears all members. No return value is returned. </p><p>The Map structure provides three traversal functions and a traversal method.</p><p>● keys()： Returns an iterator for keys.</p><p>● values()： Returns an iterator for values.</p><p>● entries()：  Returns an iterator for all members.</p><p>● forEach()：。 Traverses all members of the Map.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">const map = new Map([</span><br><span class="line">     [&quot;foo&quot;,1],</span><br><span class="line">     [&quot;bar&quot;,2],</span><br><span class="line">])</span><br><span class="line">for(let key of map.keys())&#123;</span><br><span class="line">    console.log(key);  // foo bar</span><br><span class="line">&#125;</span><br><span class="line">for(let value of map.values())&#123;</span><br><span class="line">     console.log(value); // 1 2</span><br><span class="line">&#125;</span><br><span class="line">for(let items of map.entries())&#123;</span><br><span class="line">    console.log(items);  // [&quot;foo&quot;,1]  [&quot;bar&quot;,2]</span><br><span class="line">&#125;</span><br><span class="line">map.forEach( (value,key,map) =&gt; &#123;</span><br><span class="line">     console.log(key,value); // foo 1    bar 2</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="（2）WeakMap"><a href="#（2）WeakMap" class="headerlink" title="（2）WeakMap"></a>（2）WeakMap</h2><p>WeakMap object is also a set of key-value correct sets, where keys are weakly referenced. The key must be an object. , the original data type cannot be used as a key value, but the value can be arbitrary. </p><p>This object also has the following methods: </p><p>● set(key,value)：<br>    set the key value corresponding to the key name and key, and then return the entire Map structure. If the key already has a value, the key value is updated. Otherwise, the key is generated. (Because the current Map object is returned, it can be called in chain)</p><p>● get(key)：<br>    This method reads the key value corresponding to the key. If the key cannot be found, the undefined is returned. </p><p>● has(key)：<br>    This method returns a boolean value indicating whether a key is in the current Map object. </p><p>● delete(key)：<br>    This method deletes a key and returns true. If the key fails to be deleted, false is returned. </p><p>The clear() method has been deprecated, so you can clear it by creating an empty WeakMap and replacing the original object.</p><p>The purpose of WeakMap is to store some data on an object sometimes, but this will form a reference to the object. Once the two objects are no longer needed, you must manually delete the reference. Otherwise, the garbage collection mechanism will not release the memory occupied by the objects.</p><p>And WeakMap the objects referenced by key names are all weak references. , that is, the garbage collection mechanism does not take this reference into account. Therefore, as long as other references of the referenced object are cleared, the garbage collection mechanism releases the memory occupied by the object. That is to say, once it is no longer needed, WeakMap the key name object and the corresponding key-value pair disappear automatically. You do not need to delete the reference manually. .</p><p>Summary: </p><p>●<br>    Map data structure. It is similar to an object and is also a set of correct key values. However, the range of “keys” is not limited to strings. Various types of values (including objects) can be treated as keys.</p><p>●<br>    The WeakMap structure is similar to the Map structure and is also used to generate the correct set of key values. However, WeakMap only accept objects as key names (except null) and do not accept other types of values as key names. The objects pointed to by the key name of the WeakMap are not included in the garbage collection mechanism.</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>What happens if you create a new arrow function</title>
      <link href="/2024/01/14/arrow%20functions/"/>
      <url>/2024/01/14/arrow%20functions/</url>
      
        <content type="html"><![CDATA[<!-- # What happens if you create a new arrow function --><p>The arrow function is introduced in ES6. It does not have a prototype, nor does it have its own this reference, and it cannot use the arguments parameter. Therefore, it is not possible to use the new operator with an arrow function.</p><h2 id="The-steps-to-implement-the-new-operator-are-as-follows"><a href="#The-steps-to-implement-the-new-operator-are-as-follows" class="headerlink" title="The steps to implement the new operator are as follows:"></a>The steps to implement the new operator are as follows:</h2><p>1.Create a new object</p><ol start="2"><li><p>Assign the constructor function’s scope to the new object (in other words, set the object’s proto property to point to the constructor function’s prototype property)</p></li><li><p>Point to the code in the constructor, and this in the constructor points to the object (That is, to add properties and methods to the object)</p></li><li><p>Return a new object</p></li></ol><p>Therefore, the arrow functions in the above steps cannot be executed.</p><h2 id="The-difference-between-arrow-functions-and-ordinary-functions"><a href="#The-difference-between-arrow-functions-and-ordinary-functions" class="headerlink" title="The difference between arrow functions and ordinary functions"></a>The difference between arrow functions and ordinary functions</h2><h3 id="1-Arrow-functions-are-more-concise-than-ordinary-functions"><a href="#1-Arrow-functions-are-more-concise-than-ordinary-functions" class="headerlink" title="(1) Arrow functions are more concise than ordinary functions"></a>(1) Arrow functions are more concise than ordinary functions</h3><p>● If there are no arguments, just write an empty parenthesis</p><p>● If there is only one parameter, you can omit the parentheses for the parameter</p><p>● If there are multiple parameters, separate them with commas</p><p>● If the return value of the function body is only one sentence, you can omit the braces</p><p>● If the function body does not require a return value and only has one sentence, you can prefix the statement with a void keyword. The most common is to call a function:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let fn = () =&gt; void doesNotReturn();</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="（2）Arrow-functions-do-not-have-their-own-‘this’-keyword"><a href="#（2）Arrow-functions-do-not-have-their-own-‘this’-keyword" class="headerlink" title="（2）Arrow functions do not have their own ‘this’ keyword."></a>（2）Arrow functions do not have their own ‘this’ keyword.</h3><p>The arrow function doesn’t create its own this, so it doesn’t have its own this, it just inherits this at the level above its own scope. So the pointer to this in the arrow function was already fixed when it was defined, and it doesn’t change after that.</p><h3 id="（3）This-pointer-inherited-from-the-arrow-function-never-changes"><a href="#（3）This-pointer-inherited-from-the-arrow-function-never-changes" class="headerlink" title="（3）This pointer inherited from the arrow function never changes"></a>（3）This pointer inherited from the arrow function never changes</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var id = &#x27;GLOBAL&#x27;;</span><br><span class="line">var obj = &#123;</span><br><span class="line">  id: &#x27;OBJ&#x27;,</span><br><span class="line">  a: function()&#123;</span><br><span class="line">    console.log(this.id);</span><br><span class="line">  &#125;,</span><br><span class="line">  b: () =&gt; &#123;</span><br><span class="line">    console.log(this.id);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.a();    // &#x27;OBJ&#x27;</span><br><span class="line">obj.b();    // &#x27;GLOBAL&#x27;</span><br><span class="line">new obj.a()  // undefined</span><br><span class="line">new obj.b()  // Uncaught TypeError: obj.b is not a constructor</span><br></pre></td></tr></table></figure><p>Method b of object obj is defined using an arrow function, and this in this function always points to this in the global execution environment in which it was defined, even if the function is called as a method of object obj, this still points to the Window object.</p><p>It is worth noting that the curly brackets {} used to define objects cannot form a separate execution environment, they still remain in the global execution environment.</p><h3 id="（4）The-methods-call-apply-bind-etc-cannot-change-the-reference-of-‘this’-in-arrow-functions"><a href="#（4）The-methods-call-apply-bind-etc-cannot-change-the-reference-of-‘this’-in-arrow-functions" class="headerlink" title="（4）The methods call(), apply(), bind(), etc. cannot change the reference of ‘this’ in arrow functions."></a>（4）The methods call(), apply(), bind(), etc. cannot change the reference of ‘this’ in arrow functions.</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var id = &#x27;Global&#x27;;</span><br><span class="line">let fun1 = () =&gt; &#123;</span><br><span class="line">    console.log(this.id)</span><br><span class="line">&#125;;</span><br><span class="line">fun1();                     // &#x27;Global&#x27;</span><br><span class="line">fun1.call(&#123;id: &#x27;Obj&#x27;&#125;);     // &#x27;Global&#x27;</span><br><span class="line">fun1.apply(&#123;id: &#x27;Obj&#x27;&#125;);    // &#x27;Global&#x27;</span><br><span class="line">fun1.bind(&#123;id: &#x27;Obj&#x27;&#125;)();   // &#x27;Global&#x27;</span><br></pre></td></tr></table></figure><h3 id="（5）Arrow-functions-cannot-be-used-as-constructors"><a href="#（5）Arrow-functions-cannot-be-used-as-constructors" class="headerlink" title="（5）Arrow functions cannot be used as constructors"></a>（5）Arrow functions cannot be used as constructors</h3><p>The process of constructing a function with ‘new’ has been explained above. In fact, the second step is to refer the ‘this’ in the function to the object. However, since arrow functions do not have their own ‘this’ and the ‘this’ refers to the outer execution environment, and cannot be changed, they cannot be used as constructors.</p><h3 id="（6）Arrow-functions-do-not-have-their-own-arguments"><a href="#（6）Arrow-functions-do-not-have-their-own-arguments" class="headerlink" title="（6）Arrow functions do not have their own arguments."></a>（6）Arrow functions do not have their own arguments.</h3><p>The arrow function does not have its own arguments object. Accessing arguments in an arrow function actually gets the arguments value of its outer function.</p><h3 id="（7）Arrow-functions-do-not-have-a-prototype"><a href="#（7）Arrow-functions-do-not-have-a-prototype" class="headerlink" title="（7）Arrow functions do not have a prototype."></a>（7）Arrow functions do not have a prototype.</h3><h3 id="（8）Arrow-functions-cannot-be-used-as-Generator-functions-and-cannot-use-the-yeild-keyword"><a href="#（8）Arrow-functions-cannot-be-used-as-Generator-functions-and-cannot-use-the-yeild-keyword" class="headerlink" title="（8）Arrow functions cannot be used as Generator functions and cannot use the yeild keyword"></a>（8）Arrow functions cannot be used as Generator functions and cannot use the yeild keyword</h3>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>What are the rules for type coercion of the == operator?</title>
      <link href="/2024/01/08/==%20operator/"/>
      <url>/2024/01/08/==%20operator/</url>
      
        <content type="html"><![CDATA[<!-- # What are the rules for type coercion of the == operator? --><p>For the &#x3D;&#x3D; operator,if the types of the two operands being compared are different, the type conversion is performed. If you compare whether x and y are the same, the following judgment process will be performed:</p><ol><li>First, it will determine whether the two types are the same, and compare the size of the two if they are the same;</li></ol><p>2.If the types are not the same, type conversion will be performed;</p><p>3.It will first determine whether it is comparing null and undefined, and if it is, it will return true</p><p>4.Check if the types of both are string and number, if so, the string will be converted to number.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 == &#x27;1&#x27;</span><br><span class="line">      ↓</span><br><span class="line">1 ==  1</span><br></pre></td></tr></table></figure><p>5.To determine whether one of the parties is a boolean, if so, it will change the boolean to number and then make a judgment</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x27;1&#x27; == true</span><br><span class="line">        ↓</span><br><span class="line">&#x27;1&#x27; ==  1</span><br><span class="line">        ↓</span><br><span class="line"> 1  ==  1</span><br></pre></td></tr></table></figure><p>6.Determine if one of the elements is an object and the other is a string, number, or symbol. If so, the object will be converted to its primitive type before the comparison.<br>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x27;1&#x27; == &#123; name: &#x27;js&#x27; &#125;</span><br><span class="line">        ↓</span><br><span class="line">&#x27;1&#x27; == &#x27;[object Object]&#x27;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>The difference between null and undefined</title>
      <link href="/2024/01/08/null-and-undefined/"/>
      <url>/2024/01/08/null-and-undefined/</url>
      
        <content type="html"><![CDATA[<!-- # The difference between null and undefined --><p>First of all, Undefined and Null are both basic data types. Each of these two basic data types has only one value, which is undefined and null.</p><p>Undefined means undefined, while null means empty object. When a general variable is declared but not yet defined, it will return undefined. null is mainly used to assign values to variables that may return objects as initialization.</p><p>Undefined is not a reserved word in JavaScript, which means that it can be used as a variable name, but this approach is very dangerous as it can affect the judgment of the undefined value. We can obtain secure undefined values through some methods, such as void 0.</p><p>When using typeof to judge these two types, Null typing will return “object”, which is a historical problem. Returns true when using a double equal sign to compare two types of values, and returns false when using a triple equal sign.</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Data types for Javascript</title>
      <link href="/2024/01/08/DataTypes-for-Javascript/"/>
      <url>/2024/01/08/DataTypes-for-Javascript/</url>
      
        <content type="html"><![CDATA[<!-- # Data types for Javascript --><h2 id="What-data-types-does-JavaScript-have-and-how-do-they-differ"><a href="#What-data-types-does-JavaScript-have-and-how-do-they-differ" class="headerlink" title="What data types does JavaScript have and how do they differ"></a>What data types does JavaScript have and how do they differ</h2><p>JavaScript has eight data types: Undefined, Null, Boolean, Number, String, Object, Symbol, and BigInt.</p><p>Where Symbol and BigInt are new data types in ES6:</p><p>● Symbol represents a unique and immutable data type created to resolve possible global variable conflicts.</p><p>● BigInt is a numeric type of data that can represent integers in any precision format. BigInt can be used to safely store and manipulate large integers, even if the Number is outside the range of safe integers that number can represent.</p><p>These data can be divided into raw data types and reference data types:</p><p>● Stack: raw data type</p><p>● Heap: References data types (objects, arrays, and functions)</p><p> The difference between the two types is the storage location:</p><p>● The original data type is a simple data segment directly stored in the stack, which occupies a small space and has a fixed size, and belongs to the frequently used data, so it is stored in the stack;</p><p>● An object whose data type is stored in the heap, occupying a large space and having an unfixed size. If stored in the stack, it will affect the performance of the program. The reference data type stores a pointer on the stack that points to the starting address of the entity in the heap. When the interpreter looks for a reference value, it first retrieves its address in the stack and then retrieves the entity from the heap.</p><p>The concepts of heap and stack exist in data structures and operating system memory, where:</p><p>● In the data structure, the access mode of the data in the stack is first in, last out.</p><p>● The heap is a priority queue that is sorted by priority, which can be specified by size.</p><p>In operating systems, memory is divided into stack and heap areas:</p><p>● The stack memory is automatically allocated and released by the compiler to store the parameter values of functions and the values of local variables. It operates like a stack in a data structure.</p><p>● Heap area memory is usually freed by the developer allocation, and if the developer does not free it, it may be reclaimed by the garbage collection mechanism at the end of the program.</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
